# №41, часть 17: Стандарт С++11. Поддержка многопоточности: средства синхронизации. 

* `std::mutex`, `std::recursive_mutex`, `std::timed_mutex`, `std::timed_recursive_mutex` — варианты примитива, так же известного как *lock*, необходимого для ведения политики эксклюзивного доступа к некоторому ресурсу. Доступны варианты (к примеру, `std::timed_mutex`) с ограничением по времени ожидания захвата. Если планируется передача владения ресурсом вложенным функциям в потоке, следует использовать рекурсивный вариант примитива. Заголовочный файл — `<mutex>`. 
* `std::condition_variable`, `std::condition_variable_any` — варианты примитива, так же известного как monitor. Он помогает в случаях, когда требуется оповещение одних потоков о действиях других потоков. Заголовочник — <condition_variable>. 

> *Использование mutex-примитивов напрямую может быть источником ошибок.* 

Представим, что мы захватили примитив вызовом `lock()`, и после этого из потока было выброшено исключение. В таком случае, легко забыть вернуть владение блокировкой: 
``` c++
std::mutex m; 
void thread_f() { 
  m.lock();                                   // захват владения 
  throw std::runtime_error("Mutex leak..."); 
  m.unlock();                                 // никогда не вызывается 
} 
```
Аналогичная проблема есть у многих видов ресурсов — памяти, идентификаторов ОС и т.п. В решении таких проблем помогает идиома **RAII**. Для примитивов синхронизации в стандартной библиотеке представлены RAII-обертки `std::lock_guard` и `std::unique_lock`. Они выполняют захват примитива в конструкторе и освобождение — в деструкторе. При их использовании становится намного сложнее случайно забыть освободить ресурс. 

``` c++
void thread_f() { 
  std::lock_guard<std::mutex> guard(m);       // захват владения 
  throw std::runtime_error("Mutex leak?");    // автоматическое освобождение 
} 
```
Тип `std::unique_lock` обобщает концепцию захвата mutex'а и предоставляет более широкий спектр возможностей. Например — *проверка наличия захвата* и *отложенный захват*. Аналогично `std::lock_guard`, в деструкторе происходит освобождение ресурса. 
```c++
int a = 0;                                    // ресурсы 
int b = 0; 

std::mutex m_a;                               // связанные mutex'ы 
std::mutex m_b; 

void thread_f() { 
  std::unique_lock<std::mutex> ulock1(m_a, std::defer_lock);    // отложенный захват 
  std::unique_lock<std::mutex> ulock2(m_b, std::defer_lock); 
  std::lock(ulock1, ulock2);                  // захват всех mutex'ов, без deadlock'ов 
  std::swap(a, b);                            // использование ресурсов 
} 

std::thread t1(thread_f);
std::thread t2(thread_f); 
```
Разберем пример подробнее. Имеются два ресурса, доступ к которым регулируется с помощью соответствующих блокировок. Имеется несколько потоков, каждый из которых может одновременно требовать доступа к одному или двум ресурсам. Для поддержания уникального доступа к ресурсам потоки выполняют захват блокировок. 

Можно видеть использование константы `std::defer_lock`. Она позволяет указать способ захвата объекта. Доступны варианты: 
* обычный захват        `std::try_to_lock`, 
* передача захвата      `std::adopt_lock)`,
* отложенный захват     `std::defer_lock`

Кроме этого, доступен захват с таймаутом (только для предоставляющих такую возможность типов блокировок). 

Можно видеть функцию `std::lock`. Обобщенные функции `std::lock()` и `std::try_lock()` помогают избежать проблемы, связанной со взаимной блокировкой потоков (*deadlock*). Проблема может возникнуть, когда используется несколько блокировок, и все они необходимы для выполнения некоторой операции. Например, в случае, когда блокировки производятся в разном порядке в разных потоках. В примере выше такая ситуация потенциальна возможна, если используется несколько потоков. 

В следующих частях мы продолжим 
обзор изменений в языке. 

Ссылки: 
1. [mutex](http://en.cppreference.com/w/cpp/thread/mutex)
2. [lock](http://en.cppreference.com/w/cpp/thread/lock)
3. [lock_guard](http://en.cppreference.com/w/cpp/thread/lock_guard)
4. [unique_lock](http://en.cppreference.com/w/cpp/thread/unique_lock) 
5. [Модификаторы захвата](http://en.cppreference.com/w/cpp/thread/lock_tag)
6. [Обзор потоков в С++0х](http://www.devx.com/SpecialReports/Article/38883)
7. [condition_variable](http://en.cppreference.com/w/cpp/thread/condition_variable)