# Советы о С++, №41, часть 18: Стандарт С++11.
## Поддержка многопоточности: средства синхронизации, продолжение.

Продолжаем обзор изменений в языке, которые принес стандарт С++11. В прошлой части были рассмотрены изменения, 
позволяющие работать с таким примитивом синхронизации потоков, как блокировки (mutex, lock). 
В этой части мы рассмотрим работу с мониторами (condition variables, monitor).

Мониторы могут быть полезны в случаях, когда одни потоки должны уведомлять другие потоки о своих действиях с некоторым ресурсом. 
Классическим примером такой ситуации является задача об очереди сообщений фиксированного размера, 
у которой есть несколько получателей и несколько поставщиков. Общим ресурсом здесь является очередь сообщений. 
Есть несколько способов уведомления потоков, ожидающих сообщения, о появлении нового сообщения, мы рассмотрим здесь только два: 
1. Ожидающие потоки находятся в цикле активного ожидания — постоянно забирают доступ к ресурсу, 
    проверяют наличие сообщений, отдают доступ. У этого способа есть ряд недостатков, 
    среди которых — высокое (*до 100%*) потребление процессорного времени ожидающими потоками. 
    Это может приводить к тому, что сообщения никогда не будут добавлены в очередь. 
    Понятно, что это крайне нежелательное поведение. 

2. Ожидающие потоки спят и пробуждаются только по необходимости. 
    Этот вариант позволяет решить проблемы предыдущего, но сложнее в реализации. 
    Такой способ решения проблемы и предлагают мониторы. Альтернативное название "условные переменные" связано с тем, 
    что потоки ждут выполнения некоторого условия. 
    Монитор включает в себя два компонента — условную переменную (набор ожидающих потоков) и механизм блокировки ресурса.

В стандартной библиотеке условные переменные представлены как классы `std::condition_variable` и `std::condition_variable_any`, 
расположенные в заголовочнике `<condition_variable>`. Разница между этими классами в том, что `std::condition_variable_any` 
позволяет использовать произвольный механизм блокировки ресурса, 
в то время как `std::condition_variable` может использоваться только с `std::unique_lock<std::mutex>`. 
Основные операции с условными переменными: ожидание выполнения условия (`wait`) и оповещение ожидающих потоков (`notify_one`, `notify_all`). 
Дополнительно к основным операциям, доступны операции ожидания ограниченные по времени. Класс является перемещаемым, но не копируемым.

Пример оповещения потоков:
``` С++
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <mutex>
#include <thread>

int i = 0; // ресурс
std::mutex m_i; // механизм блокировки доступа
std::condition_variable cv; // условная переменная

void consumer_thread_f() {
    std::unique_lock<std::mutex> lock(m_i); // ждем доступа к ресурсу
    while (i >= 0) { // условие, которого ждет рабочий поток
        // блокировка должна быть захвачена перед вызовом wait!
        cv.wait(lock); // ждем оповещения об изменении ресурса
    }
    // этот цикл можно заменить на cv.wait(lock, [] { return i < 0; });
    // выход из ожидания происходит с захватом блокировки
    ++i; // используем ресурс
    // автоматическое освобождение блокировки в деструкторе lock
}

void producer_thread_f() {
    // дадим время потокам на вход в ожидание
    std::this_thread::sleep_for(std::chrono::seconds(1));   
    std::unique_lock<std::mutex> lock(m_i); // захват блокировки
    i = -100; // изменение ресурса
    lock.unlock(); // не обязательно держать блокировку для оповещения
    cv.notify_all(); // оповещение всех ожидающих потоков
}

int main(int argc, char** argv)
{
    std::thread consumer_thread1(consumer_thread_f);
    std::thread consumer_thread2(consumer_thread_f);
    std::thread producer_thread(producer_thread_f);
    consumer_thread1.join();
    consumer_thread2.join()
    producer_thread.join();
    std::cout << i; // В результате ожидаем значение i == -98;

    return 0;
}
```

Упомянем о нескольких подводных камнях, связанных с условными переменными. 
1. Следует помнить, что вызов **wait предполагает наличие захваченной блокировки** этим потоком, в противном случае поведение не определено. 
    Перед выходом из функции блокировка восстанавливается для вызывавшего wait потока.

1. В силу особенностей реализации потоков в ОС, возможны случайные пробуждения ожидающих потоков (spurious wakeups), 
    а следовательно, и из вызова `wait`. Из-за этого рекомендуется производить ожидание в цикле (как в примере), 
    *даже если есть уверенность*, что любой вызов `notify_one` приведет к выполнению необходимого условия. 

1. Наконец, вызов `notify_one`, произведенный без освобождения блокировки, приведет к лишней итерации ожидания. 
    Поэтому, рекомендуется освобождать блокировку перед оповещением. 
    В некоторых случаях это, однако, может быть необходимостью. Например, если ожидающий поток попытается удалить объект блокировки.


В следующих частях мы продолжим обзор изменений в языке.

## Ссылки:
1. [condition_variable (cppreference)](http://en.cppreference.com/w/cpp/thread/condition_variable)
1. [Мониторы (Wiki)](https://en.wikipedia.org/wiki/Monitor_(synchronization))
1. [Spurious wakeup (Wiki)](https://en.wikipedia.org/wiki/Spurious_wakeup)
